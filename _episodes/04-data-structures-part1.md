---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 04-data-structures-part1.md in _episodes_rmd/
title: "자료구조(Data Structures)"
teaching: 40
exercises: 15
questions:
- "R에 데이터를 어떻게 불러올 수 있을까?"
- "R에서 기본 자료구조는 무엇인가?"
- "R에서 범주형 정보를 어떻게 표현하는가?"
objectives:
- "다양한 자료형에 대해 인지한다."
- "데이터프레임 탐색을 시작하는데 벡터, 요인(factor), 리스트가 어떻게 연관되는지 이해한다"
- "자료형, 클래스, 객체 구조에 관해 파악하고자 R에 질문을 던진다."
keypoints:
- "`read.csv` 함수를 사용해서 R에 표형태 데이터를 불러온다."
- "R의 기본자료형은 실수형, 정수형, 복소수형, 논리형, 문자형이다"
- "R에서 인자를 사용해서 범주를 표현한다."
source: Rmd
---



R의 가장 강력한 기능중 하나는 표형식 데이터를 다룰 수 있는 능력이다 - 
이미 스프레드쉬트나 CSV 파일을 갖고 있을 수 있다. 
`data/` 디렉토리에 `feline-data.csv` 파일을 생성하면서 학습을 시작해 보자:


~~~
cats <- data.frame(coat = c("calico", "black", "tabby"), 
                    weight = c(2.1, 5.0,3.2), 
                    likes_string = c(1, 0, 1))
write.csv(x = cats, file = "data/feline-data.csv", row.names = FALSE)
~~~
{: .language-r}

새로 생성한 `feline-data.csv` 파일 내부는 다음과 같다:

~~~
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
~~~
{: .language-r}

> ## Tip: R에서 텍스트 파일 편집
>
> 대안으로, `data/feline-data.csv` 파일을 생성하는데 나노 편집기(Nano)를 사용하거나,
> RStudio **File -> New File -> Text File** 메뉴를 사용할 수 있다.
>
{: .callout}

다음 명령어를 통해서 R로 데이터를 불러 가져온다:


~~~
cats <- read.csv(file = "data/feline-data.csv")
cats
~~~
{: .language-r}



~~~
    coat weight likes_string
1 calico    2.1            1
2  black    5.0            0
3  tabby    3.2            1
~~~
{: .output}

`read.table` 함수를 사용해서 텍스트 파일에 저장된 표형식 데이터를 불러오는데 사용한다.
표형식 데이터는 CSV (csv = 콤마구분 값) 같은 구분 문자(punctuation characters)로 칼럼이 구분된다.
csv 파일에 데이터를 구분하는데 가장 일반적으로 사용되는 구분 문자가 탭과 콤마다.
R에서 사용의 편리성을 위해서 `read.table` 함수에 두가지 다른 버전 함수를 제공한다.
`read.csv`가 콤마로 구분되는 데이터를 읽어들이는데 사용하고, `read.delim` 함수가 
탭으로 구분되는 데이터를 읽어오는데 사용된다. `read.csv` 함수가 둘중에 더 많이 사용된다.
필요한 경우 `read.csv`, `read.delim` 함수 모두 구분문자를 오버라이드해서 사용하는 것도 가능하다.

데이터프레임에 `$` 연산자를 사용해서 칼럼을 뽑아내면서 데이터셋에서 바로 탐색을 시작하는 것도 가능하다.


~~~
cats$weight
~~~
{: .language-r}



~~~
[1] 2.1 5.0 3.2
~~~
{: .output}



~~~
cats$coat
~~~
{: .language-r}



~~~
[1] calico black  tabby 
Levels: black calico tabby
~~~
{: .output}

칼럼에 다른 연산자 적용도 할 수 있다:


~~~
## 내 고양이 몸무게가 2 kg 불었다고 다음과 같이 표현할 수 있다:
cats$weight + 2
~~~
{: .language-r}



~~~
[1] 4.1 7.0 5.2
~~~
{: .output}



~~~
paste("My cat is", cats$coat)
~~~
{: .language-r}



~~~
[1] "My cat is calico" "My cat is black"  "My cat is tabby" 
~~~
{: .output}

이번에 다음은 어떤가?


~~~
cats$weight + cats$coat
~~~
{: .language-r}



~~~
Warning in Ops.factor(cats$weight, cats$coat): 요인(factors)에 대하여 의미
있는 '+'가 아닙니다.
~~~
{: .error}



~~~
[1] NA NA NA
~~~
{: .output}

상기 문장에서 발생된 것을 이해하는 것이 R로 데이터 분석을 성공적으로 수행하는데 중요하다.

## 자료형(Data Types)

`2.1` 더하기 `"black"`이 말이 되지 않기 때문에 마지막 문장이 오류를 뱉어낼 것이라고 추측한다면,
제대로 이해하고 있는 것이다. 이미 *자료형(data type)*으로 불리는 프로그래밍의 중요한 개념에 대한
직관을 갖추고 있는 것이다.
데이터 자료형이 무엇인지 다음을 통해 물어보게 된다:


~~~
typeof(cats$weight)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}

다섯가지 주요 자료형이 있다: 실수형(`double`), 정수형(`integer`), 복소수형(`complex`), 논리형(`logical`), 문자형(`character`).



~~~
typeof(3.14)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}



~~~
typeof(1L) # The L suffix forces the number to be an integer, since by default R uses float numbers
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
typeof(1+1i)
~~~
{: .language-r}



~~~
[1] "complex"
~~~
{: .output}



~~~
typeof(TRUE)
~~~
{: .language-r}



~~~
[1] "logical"
~~~
{: .output}



~~~
typeof('banana')
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}

분석이 얼마나 복잡해지냐에 관계없이, R에서 모든 데이터는 이러한 기본 자료형 중 하나로 해석된다.
이러한 엄격함이 정말로 중요한 결과를 잉태하게 된다.

사용자가 또다른 고양이에 대한 상세내용을 추가했고, 추가 정보는 
`data/feline-data_v2.csv` 파일에 저장되어 있다.



~~~
file.show("data/feline-data_v2.csv")
~~~
{: .language-r}


~~~
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
tabby,2.3 or 2.4,1
~~~
{: .language-r}

앞서와 마찬가지로 새로운 고양이 데이터를 불러와서 `weight` 칼럼에 데이터 자료형이 무엇인지 확인한다:


~~~
cats <- read.csv(file="data/feline-data_v2.csv")
typeof(cats$weight)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

이러면 안되는데, 고양이 몸무게가 더이상 실수형 자료형이 아니다!
앞서 수행했던 동일한 수학연산을 취하게 되면 문제에 봉착한다:


~~~
cats$weight + 2
~~~
{: .language-r}



~~~
Warning in Ops.factor(cats$weight, 2): 요인(factors)에 대하여 의미있는
'+'가 아닙니다.
~~~
{: .error}



~~~
[1] NA NA NA NA
~~~
{: .output}

무슨 일이 일어난 걸까? R이 csv 파일을 불러올 때, 
칼럼에 모든 것이 동일한 자료형이 되는 것을 요구한다;
칼럼에 모든 원소가 실수형으로 인식되지 않으면, 칼럼에 *어떤 원소도* 실수형이 될 수 없다.
고양이 데이터를 불러온 테이블을 *데이터프레임(data.frame)*이라고 부르고, *자료구조(data structure)*로 불리는 
첫번째 사례가 된다. 즉, 자료구조는 기본 자료형에서 R이 생성할 줄 아는 구조가 된다.

`class` 함수를 호출해서 *데이터프레임*인지를 알 수 있다:


~~~
class(cats)
~~~
{: .language-r}



~~~
[1] "data.frame"
~~~
{: .output}

R에서 데이터를 성공적으로 사용하려면, 기본 자료구조가 무엇인지, 어떻게 동작하는지 이해할 필요가 있다.
지금으로서는 추가된 마지막 줄을 제거하고 좀더 살펴보도록 하자:

feline-data.csv:

```
coat,weight,likes_string
calico,2.1,1
black,5.0,0
tabby,3.2,1
```

RStudio로 다시 돌아와서:


~~~
cats <- read.csv(file="data/feline-data.csv")
~~~
{: .language-r}




## 벡터와 자료형 강제변환(Type Coercion)

강제변환을 보다 잘 이해하기 위해서, 또 다른 자료구조를 만나보자: *벡터(vector)*.


~~~
my_vector <- vector(length = 3)
my_vector
~~~
{: .language-r}



~~~
[1] FALSE FALSE FALSE
~~~
{: .output}

R에서 벡터는 본질적으로 무언가 순서를 갖는 리스트로, 특별한 성질을 갖는데 *벡터에 모든 것은 
동일한 자료형을 갖는다는 점이다.* 자료형을 지정하지 않게 되면, 기본디폴트 설정은 `논리형(logical)`이 되거나;
자료형에 관계없이 공벡터를 선언할 수 있다.


~~~
another_vector <- vector(mode='character', length=3)
another_vector
~~~
{: .language-r}



~~~
[1] "" "" ""
~~~
{: .output}

자료가 벡터인지 다음과 같이 확인한다:


~~~
str(another_vector)
~~~
{: .language-r}



~~~
 chr [1:3] "" "" ""
~~~
{: .output}

상기 명령어로부터 다소 암호스러운 출력결과가 나오는데 해당 벡터에서 발견된 기본 자료형은 
이 경우 `chr` 문자; 벡터에 나와있는 숫자는 벡터의 인덱스로 이 경우 `[1:3]`;
그리고 벡터에 실제로 들어있는 몇가지 예로, 이 경우 빈 문자열이 된다. 
유사하게 다음을 실행하게 되면;



~~~
str(cats$weight)
~~~
{: .language-r}



~~~
 num [1:3] 2.1 5 3.2
~~~
{: .output}

`cats$weight`도 벡터임을 알 수 있다 - *R 데이터프레임으로 불러온 데이터 칼럼은 모두 벡터다*, 그리고
이러한 연유로 칼럼에 있는 모든 원소는 동일한 자료형을 갖게 강제하는 이유가 된다.

> ## 토론 1
>
> 왜 R에서는 데이터 칼럼에 무엇을 넣는지에 대해서 고집스럽게 주장을 할까?
> 이러한 점은 어떻게 우리에게 도움이 될까?
>
> > ## 토론 1
> >
> > 칼럼에 모든 것을 동일하게 둠으로써, 데이터에 관해서 단순한 가정을 할 수 있게 한다;
> > 만약 칼럼의 첫번째 입력값이 숫자라면, *모든* 입력값을 숫자로 해석할 수 있게 되고,
> > 그렇게 함으로써 모든 것을 확인할 필요가 없게 된다.
> > *깨끗한 데이터(clean data)*라고 사람들이 회자할 때, 사람들이 의미하는 것이 이러한 일관성이다.
> > 장기적으로 엄격한 일관성이 R에서 우리 삶을 풍요롭고 수월하게 만들 것이다.
> {: .solution}
{: .discussion}

결합 함수(`c()`)를 사용해서 벡터를 생성할 수 있다:


~~~
combine_vector <- c(2,6,3)
combine_vector
~~~
{: .language-r}



~~~
[1] 2 6 3
~~~
{: .output}

지금까지 학습한 것을 바탕으로, 다음 문장은 어떤 결과를 출력하게 될까?


~~~
quiz_vector <- c(2,6,'3')
~~~
{: .language-r}

이것을 *자료형 강제변환(type coercion)*라고 부른다.
이것이 많은 놀라움의 원천이고, 왜 기본 자료형에 대해서 인지하고 있어야 되는 이유가 되고,
R이 해석하는 방식도 알아야 된다. 
R에서 혼합된 자료형(상기 예제는 숫자와 문자)의 경우 단하나의 벡터로 변환시킬 때, 모든 자료를 동일한 자료형으로 강제 변환시킨다.
다음을 생각해 보자.



~~~
coercion_vector <- c('a', TRUE)
coercion_vector
~~~
{: .language-r}



~~~
[1] "a"    "TRUE"
~~~
{: .output}



~~~
another_coercion_vector <- c(0, TRUE)
another_coercion_vector
~~~
{: .language-r}



~~~
[1] 0 1
~~~
{: .output}

강제 변환규칙은 다음과 같이 적용된다: `논리형` -> `정수형` -> `숫자형` -> `복소수형` ->
`문자형`. 여기서 -> 표현은 다음으로 변환된다로 읽힌다.
이런 자동 변환규칙에 거슬러 자료형을 강제로 변환시키려면 `as.` 함수를 사용한다:


~~~
character_vector_example <- c('0','2','4')
character_vector_example
~~~
{: .language-r}



~~~
[1] "0" "2" "4"
~~~
{: .output}



~~~
character_coerced_to_numeric <- as.numeric(character_vector_example)
character_coerced_to_numeric
~~~
{: .language-r}



~~~
[1] 0 2 4
~~~
{: .output}



~~~
numeric_coerced_to_logical <- as.logical(character_coerced_to_numeric)
numeric_coerced_to_logical
~~~
{: .language-r}



~~~
[1] FALSE  TRUE  TRUE
~~~
{: .output}



As you can see, some surprising things can happen when R forces one basic data
type into another! Nitty-gritty of type coercion aside, the point is: if your
data doesn't look like what you thought it was going to look like, type coercion
may well be to blame; make sure everything is the same type in your vectors and
your columns of data.frames, or you will get nasty surprises!

But coercion can also be very useful! For example, in our `cats` data
`likes_string` is numeric, but we know that the 1s and 0s actually represent
`TRUE` and `FALSE` (a common way of representing them). We should use the
`logical` datatype here, which has two states: `TRUE` or `FALSE`, which is
exactly what our data represents. We can 'coerce' this column to be `logical` by
using the `as.logical` function:


~~~
cats$likes_string
~~~
{: .language-r}



~~~
[1] 1 0 1
~~~
{: .output}



~~~
cats$likes_string <- as.logical(cats$likes_string)
cats$likes_string
~~~
{: .language-r}



~~~
[1]  TRUE FALSE  TRUE
~~~
{: .output}

The combine function, `c()`, will also append things to an existing vector:


~~~
ab_vector <- c('a', 'b')
ab_vector
~~~
{: .language-r}



~~~
[1] "a" "b"
~~~
{: .output}



~~~
combine_example <- c(ab_vector, 'SWC')
combine_example
~~~
{: .language-r}



~~~
[1] "a"   "b"   "SWC"
~~~
{: .output}

You can also make series of numbers:


~~~
mySeries <- 1:10
mySeries
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(10)
~~~
{: .language-r}



~~~
 [1]  1  2  3  4  5  6  7  8  9 10
~~~
{: .output}



~~~
seq(1,10, by=0.1)
~~~
{: .language-r}



~~~
 [1]  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3
[15]  2.4  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7
[29]  3.8  3.9  4.0  4.1  4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.0  5.1
[43]  5.2  5.3  5.4  5.5  5.6  5.7  5.8  5.9  6.0  6.1  6.2  6.3  6.4  6.5
[57]  6.6  6.7  6.8  6.9  7.0  7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9
[71]  8.0  8.1  8.2  8.3  8.4  8.5  8.6  8.7  8.8  8.9  9.0  9.1  9.2  9.3
[85]  9.4  9.5  9.6  9.7  9.8  9.9 10.0
~~~
{: .output}

We can ask a few questions about vectors:


~~~
sequence_example <- seq(10)
head(sequence_example, n=2)
~~~
{: .language-r}



~~~
[1] 1 2
~~~
{: .output}



~~~
tail(sequence_example, n=4)
~~~
{: .language-r}



~~~
[1]  7  8  9 10
~~~
{: .output}



~~~
length(sequence_example)
~~~
{: .language-r}



~~~
[1] 10
~~~
{: .output}



~~~
class(sequence_example)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
typeof(sequence_example)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

Finally, you can give names to elements in your vector:


~~~
my_example <- 5:8
names(my_example) <- c("a", "b", "c", "d")
my_example
~~~
{: .language-r}



~~~
a b c d 
5 6 7 8 
~~~
{: .output}



~~~
names(my_example)
~~~
{: .language-r}



~~~
[1] "a" "b" "c" "d"
~~~
{: .output}

> ## Challenge 1
>
> Start by making a vector with the numbers 1 through 26.
> Multiply the vector by 2, and give the resulting vector
> names A through Z (hint: there is a built in vector called `LETTERS`)
>
> > ## Solution to Challenge 1
> >
> > 
> > ~~~
> > x <- 1:26
> > x <- x * 2
> > names(x) <- LETTERS
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}


## Data Frames

We said that columns in data.frames were vectors:


~~~
str(cats$weight)
~~~
{: .language-r}



~~~
 num [1:3] 2.1 5 3.2
~~~
{: .output}



~~~
str(cats$likes_string)
~~~
{: .language-r}



~~~
 logi [1:3] TRUE FALSE TRUE
~~~
{: .output}

These make sense. But what about


~~~
str(cats$coat)
~~~
{: .language-r}



~~~
 Factor w/ 3 levels "black","calico",..: 2 1 3
~~~
{: .output}

## Factors

Another important data structure is called a *factor*. Factors usually look like
character data, but are typically used to represent categorical information. For
example, let's make a vector of strings labelling cat colorations for all the
cats in our study:


~~~
coats <- c('tabby', 'tortoiseshell', 'tortoiseshell', 'black', 'tabby')
coats
~~~
{: .language-r}



~~~
[1] "tabby"         "tortoiseshell" "tortoiseshell" "black"        
[5] "tabby"        
~~~
{: .output}



~~~
str(coats)
~~~
{: .language-r}



~~~
 chr [1:5] "tabby" "tortoiseshell" "tortoiseshell" "black" "tabby"
~~~
{: .output}

We can turn a vector into a factor like so:


~~~
CATegories <- factor(coats)
class(CATegories)
~~~
{: .language-r}



~~~
[1] "factor"
~~~
{: .output}



~~~
str(CATegories)
~~~
{: .language-r}



~~~
 Factor w/ 3 levels "black","tabby",..: 2 3 3 1 2
~~~
{: .output}

Now R has noticed that there are three possible categories in our data - but it
also did something surprising; instead of printing out the strings we gave it,
we got a bunch of numbers instead. R has replaced our human-readable categories
with numbered indices under the hood, this is necessary as many statistical
calculations utilise such numerical representations for categorical data:


~~~
typeof(coats)
~~~
{: .language-r}



~~~
[1] "character"
~~~
{: .output}



~~~
typeof(CATegories)
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}

> ## Challenge 2
>
> Is there a factor in our `cats` data.frame? what is its name?
> Try using `?read.csv` to figure out how to keep text columns as character
> vectors instead of factors; then write a command or two to show that the factor
> in `cats` is actually a character vector when loaded in this way.
>
> > ## Solution to Challenge 2
> >
> > One solution is use the argument `stringAsFactors`:
> >
> > 
> > ~~~
> > cats <- read.csv(file="data/feline-data.csv", stringsAsFactors=FALSE)
> > str(cats$coat)
> > ~~~
> > {: .language-r}
> >
> > Another solution is use the argument `colClasses`
> > that allow finer control.
> >
> > 
> > ~~~
> > cats <- read.csv(file="data/feline-data.csv", colClasses=c(NA, NA, "character"))
> > str(cats$coat)
> > ~~~
> > {: .language-r}
> >
> > Note: new students find the help files difficult to understand; make sure to let them know
> > that this is typical, and encourage them to take their best guess based on semantic meaning,
> > even if they aren't sure.
> {: .solution}
{: .challenge}

In modelling functions, it's important to know what the baseline levels are. This
is assumed to be the first factor, but by default factors are labelled in
alphabetical order. You can change this by specifying the levels:


~~~
mydata <- c("case", "control", "control", "case")
factor_ordering_example <- factor(mydata, levels = c("control", "case"))
str(factor_ordering_example)
~~~
{: .language-r}



~~~
 Factor w/ 2 levels "control","case": 2 1 1 2
~~~
{: .output}

In this case, we've explicitly told R that "control" should represented by 1, and
"case" by 2. This designation can be very important for interpreting the
results of statistical models!

## Lists

Another data structure you'll want in your bag of tricks is the `list`. A list
is simpler in some ways than the other types, because you can put anything you
want in it:


~~~
list_example <- list(1, "a", TRUE, 1+4i)
list_example
~~~
{: .language-r}



~~~
[[1]]
[1] 1

[[2]]
[1] "a"

[[3]]
[1] TRUE

[[4]]
[1] 1+4i
~~~
{: .output}



~~~
another_list <- list(title = "Numbers", numbers = 1:10, data = TRUE )
another_list
~~~
{: .language-r}



~~~
$title
[1] "Numbers"

$numbers
 [1]  1  2  3  4  5  6  7  8  9 10

$data
[1] TRUE
~~~
{: .output}

We can now understand something a bit surprising in our data.frame; what happens if we run:


~~~
typeof(cats)
~~~
{: .language-r}



~~~
[1] "list"
~~~
{: .output}

We see that data.frames look like lists 'under the hood' - this is because a
data.frame is really a list of vectors and factors, as they have to be - in
order to hold those columns that are a mix of vectors and factors, the
data.frame needs something a bit more flexible than a vector to put all the
columns together into a familiar table.  In other words, a `data.frame` is a
special list in which all the vectors must have the same length.

In our `cats` example, we have an integer, a double and a logical variable. As
we have seen already, each column of data.frame is a vector.


~~~
cats$coat
~~~
{: .language-r}



~~~
[1] calico black  tabby 
Levels: black calico tabby
~~~
{: .output}



~~~
cats[,1]
~~~
{: .language-r}



~~~
[1] calico black  tabby 
Levels: black calico tabby
~~~
{: .output}



~~~
typeof(cats[,1])
~~~
{: .language-r}



~~~
[1] "integer"
~~~
{: .output}



~~~
str(cats[,1])
~~~
{: .language-r}



~~~
 Factor w/ 3 levels "black","calico",..: 2 1 3
~~~
{: .output}

Each row is an *observation* of different variables, itself a data.frame, and
thus can be composed of elements of different types.


~~~
cats[1,]
~~~
{: .language-r}



~~~
    coat weight likes_string
1 calico    2.1         TRUE
~~~
{: .output}



~~~
typeof(cats[1,])
~~~
{: .language-r}



~~~
[1] "list"
~~~
{: .output}



~~~
str(cats[1,])
~~~
{: .language-r}



~~~
'data.frame':	1 obs. of  3 variables:
 $ coat        : Factor w/ 3 levels "black","calico",..: 2
 $ weight      : num 2.1
 $ likes_string: logi TRUE
~~~
{: .output}

> ## Challenge 3
>
> There are several subtly different ways to call variables, observations and
> elements from data.frames:
>
> - `cats[1]`
> - `cats[[1]]`
> - `cats$coat`
> - `cats["coat"]`
> - `cats[1, 1]`
> - `cats[, 1]`
> - `cats[1, ]`
>
> Try out these examples and explain what is returned by each one.
>
> *Hint:* Use the function `typeof()` to examine what is returned in each case.
>
> > ## Solution to Challenge 3
> > 
> > ~~~
> > cats[1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     coat
> > 1 calico
> > 2  black
> > 3  tabby
> > ~~~
> > {: .output}
> > We can think of a data frame as a list of vectors. The single brace `[1]`
> returns the first slice of the list, as another list. In this case it is the
> first column of the data frame.
> > 
> > ~~~
> > cats[[1]]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] calico black  tabby 
> > Levels: black calico tabby
> > ~~~
> > {: .output}
> > The double brace `[[1]]` returns the contents of the list item. In this case
> it is the contents of the first column, a _vector_ of type _factor_.
> > 
> > ~~~
> > cats$coat
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] calico black  tabby 
> > Levels: black calico tabby
> > ~~~
> > {: .output}
> > This example uses the `$` character to address items by name. _coat_ is the
> first column of the data frame, again a _vector_ of type _factor_.
> > 
> > ~~~
> > cats["coat"]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     coat
> > 1 calico
> > 2  black
> > 3  tabby
> > ~~~
> > {: .output}
> > Here we are using a single brace `["coat"]` replacing the index number with
> the column name. Like example 1, the returned object is a _list_.
> > 
> > ~~~
> > cats[1, 1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] calico
> > Levels: black calico tabby
> > ~~~
> > {: .output}
> > This example uses a single brace, but this time we provide row and column
> coordinates. The returned object is the value in row 1, column 1. The object
> is an _integer_ but because it is part of a _vector_ of type _factor_, R
> displays the label "calico" associated with the integer value.
> > 
> > ~~~
> > cats[, 1]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] calico black  tabby 
> > Levels: black calico tabby
> > ~~~
> > {: .output}
> > Like the previous example we use single braces and provide row and column
> coordinates. The row coordinate is not specified, R interprets this missing
> value as all the elements in this _column_ _vector_.
> > 
> > ~~~
> > cats[1, ]
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> >     coat weight likes_string
> > 1 calico    2.1         TRUE
> > ~~~
> > {: .output}
> > Again we use the single brace with row and column coordinates. The column
> coordinate is not specified. The return value is a _list_ containing all the
> values in the first row.
> {: .solution}
{: .challenge}

## Matrices

Last but not least is the matrix. We can declare a matrix full of zeros:


~~~
matrix_example <- matrix(0, ncol=6, nrow=3)
matrix_example
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    0    0    0    0    0    0
[2,]    0    0    0    0    0    0
[3,]    0    0    0    0    0    0
~~~
{: .output}

And similar to other data structures, we can ask things about our matrix:


~~~
class(matrix_example)
~~~
{: .language-r}



~~~
[1] "matrix"
~~~
{: .output}



~~~
typeof(matrix_example)
~~~
{: .language-r}



~~~
[1] "double"
~~~
{: .output}



~~~
str(matrix_example)
~~~
{: .language-r}



~~~
 num [1:3, 1:6] 0 0 0 0 0 0 0 0 0 0 ...
~~~
{: .output}



~~~
dim(matrix_example)
~~~
{: .language-r}



~~~
[1] 3 6
~~~
{: .output}



~~~
nrow(matrix_example)
~~~
{: .language-r}



~~~
[1] 3
~~~
{: .output}



~~~
ncol(matrix_example)
~~~
{: .language-r}



~~~
[1] 6
~~~
{: .output}

> ## Challenge 4
>
> What do you think will be the result of
> `length(matrix_example)`?
> Try it.
> Were you right? Why / why not?
>
> > ## Solution to Challenge 4
> >
> > What do you think will be the result of
> > `length(matrix_example)`?
> >
> > 
> > ~~~
> > matrix_example <- matrix(0, ncol=6, nrow=3)
> > length(matrix_example)
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > [1] 18
> > ~~~
> > {: .output}
> >
> > Because a matrix is a vector with added dimension attributes, `length`
> > gives you the total number of elements in the matrix.
> {: .solution}
{: .challenge}


> ## Challenge 5
>
> Make another matrix, this time containing the numbers 1:50,
> with 5 columns and 10 rows.
> Did the `matrix` function fill your matrix by column, or by
> row, as its default behaviour?
> See if you can figure out how to change this.
> (hint: read the documentation for `matrix`!)
>
> > ## Solution to Challenge 5
> >
> > Make another matrix, this time containing the numbers 1:50,
> > with 5 columns and 10 rows.
> > Did the `matrix` function fill your matrix by column, or by
> > row, as its default behaviour?
> > See if you can figure out how to change this.
> > (hint: read the documentation for `matrix`!)
> >
> > 
> > ~~~
> > x <- matrix(1:50, ncol=5, nrow=10)
> > x <- matrix(1:50, ncol=5, nrow=10, byrow = TRUE) # to fill by row
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}


> ## Challenge 6
>  Create a list of length two containing a character vector for each of the sections in this part of the workshop:
>
>  - Data types
>  - Data structures
>
>  Populate each character vector with the names of the data types and data
>  structures we've seen so far.
>
> > ## Solution to Challenge 6
> > 
> > ~~~
> > dataTypes <- c('double', 'complex', 'integer', 'character', 'logical')
> > dataStructures <- c('data.frame', 'vector', 'factor', 'list', 'matrix')
> > answer <- list(dataTypes, dataStructures)
> > ~~~
> > {: .language-r}
> > Note: it's nice to make a list in big writing on the board or taped to the wall
> > listing all of these types and structures - leave it up for the rest of the workshop
> > to remind people of the importance of these basics.
> >
> {: .solution}
{: .challenge}


> ## Challenge 7
>
> Consider the R output of the matrix below:
> 
> ~~~
>      [,1] [,2]
> [1,]    4    1
> [2,]    9    5
> [3,]   10    7
> ~~~
> {: .output}
> What was the correct command used to write this matrix? Examine
> each command and try to figure out the correct one before typing them.
> Think about what matrices the other commands will produce.
>
> 1. `matrix(c(4, 1, 9, 5, 10, 7), nrow = 3)`
> 2. `matrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)`
> 3. `matrix(c(4, 9, 10, 1, 5, 7), nrow = 2)`
> 4. `matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)`
>
> > ## Solution to Challenge 7
> >
> > Consider the R output of the matrix below:
> > 
> > ~~~
> >      [,1] [,2]
> > [1,]    4    1
> > [2,]    9    5
> > [3,]   10    7
> > ~~~
> > {: .output}
> > What was the correct command used to write this matrix? Examine
> > each command and try to figure out the correct one before typing them.
> > Think about what matrices the other commands will produce.
> > 
> > ~~~
> > matrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)
> > ~~~
> > {: .language-r}
> {: .solution}
{: .challenge}
